[
     {
          "algorithm": "Novel algorithm: At each step, select the next node by balancing proximity to the current node and alignment toward the destination, weighted by the remaining unvisited nodes' distribution.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    current_distances = distance_matrix[current_node, unvisited_nodes]\n    dest_distances = distance_matrix[destination_node, unvisited_nodes]\n    proximity_weight = 0.6  # Weight for proximity to current node\n    alignment_weight = 0.4  # Weight for alignment toward destination\n    scores = proximity_weight * current_distances - alignment_weight * dest_distances\n    next_node_idx = np.argmin(scores)\n    next_node = unvisited_nodes[next_node_idx]\n    return next_node",
          "objective": 6.13382,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: Balance proximity to current node, alignment towards destination, and dispersion from other unvisited nodes using weighted exponential terms and a dispersion penalty.",
          "code": "import numpy as np  \n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):  \n    if len(unvisited_nodes) == 0:  \n        return destination_node  \n    current_distances = distance_matrix[current_node, unvisited_nodes]  \n    dest_distances = distance_matrix[destination_node, unvisited_nodes]  \n    avg_distance = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)])  \n    proximity_weight = 0.4 * (1 - np.exp(-current_distances / avg_distance))  \n    alignment_weight = 0.3 * np.exp(-dest_distances / avg_distance)  \n    dispersion = np.sum(distance_matrix[np.ix_([current_node], unvisited_nodes)], axis=0) / len(unvisited_nodes)  \n    dispersion_weight = 0.3 * (1 - np.exp(-dispersion / avg_distance))  \n    scores = proximity_weight + alignment_weight + dispersion_weight  \n    next_node_idx = np.argmin(scores)  \n    next_node = unvisited_nodes[next_node_idx]  \n    return next_node",
          "objective": 6.34315,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm selects the next node by maximizing the ratio of the distance from the current node to the sum of distances from all unvisited nodes, favoring nodes that are relatively closer to the current node compared to others.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    current_dist = distance_matrix[current_node, unvisited_nodes]\n    total_dist = np.sum(distance_matrix[unvisited_nodes][:, unvisited_nodes], axis=1)\n    scores = current_dist / (total_dist + 1e-8)\n    next_node_idx = np.argmin(scores)\n    next_node = unvisited_nodes[next_node_idx]\n    return next_node",
          "objective": 6.34985,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    current_distances = distance_matrix[current_node, unvisited_nodes]\n    dest_distances = distance_matrix[destination_node, unvisited_nodes]\n    avg_distance = np.mean(distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)])\n    proximity_weight = 0.5 * (1 - np.exp(-current_distances / avg_distance))\n    alignment_weight = 0.5 * np.exp(-dest_distances / avg_distance)\n    scores = proximity_weight + alignment_weight\n    next_node_idx = np.argmin(scores)\n    next_node = unvisited_nodes[next_node_idx]\n    return next_node",
          "objective": 6.56392,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm selects the next node by minimizing a weighted sum of the distance from the current node and the harmonic mean of distances to all other unvisited nodes, emphasizing nodes that are both close to the current node and centrally located among unvisited nodes.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    current_dist = distance_matrix[current_node, unvisited_nodes]\n    harmonic_mean = len(unvisited_nodes) / np.sum(1.0 / (distance_matrix[np.ix_(unvisited_nodes, unvisited_nodes)] + 1e-8), axis=1)\n    scores = 0.6 * current_dist + 0.4 * harmonic_mean\n    next_node_idx = np.argmin(scores)\n    next_node = unvisited_nodes[next_node_idx]\n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     }
]